// This file was GENERATED by command:
//     pump.py closure.h.pump
// DO NOT EDIT BY HAND!!!

 // Copyright 2014. All rights reserved.
 // Author: Nelson LIAO <liaoxin1014@gmail.com>

class ClosureBase {
 public:
  virtual ~ClosureBase() {}
  virtual bool IsRepeatable() const = 0;
};

template<typename Signature>
class Closure : public ClosureBase {};

template<class R >
class Closure<R ()> : public ClosureBase {
 public:
  virtual R Run() = 0;
};

template<class R , typename A1>
class Closure<R (A1)> : public ClosureBase {
 public:
  virtual R Run(A1 a1) = 0;
};

template<class R , typename A1, typename A2>
class Closure<R (A1, A2)> : public ClosureBase {
 public:
  virtual R Run(A1 a1, A2 a2) = 0;
};

template<class R , typename A1, typename A2, typename A3>
class Closure<R (A1, A2, A3)> : public ClosureBase {
 public:
  virtual R Run(A1 a1, A2 a2, A3 a3) = 0;
};

template<class R , typename A1, typename A2, typename A3, typename A4>
class Closure<R (A1, A2, A3, A4)> : public ClosureBase {
 public:
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4) = 0;
};

template<class R , typename A1, typename A2, typename A3, typename A4,
    typename A5>
class Closure<R (A1, A2, A3, A4, A5)> : public ClosureBase {
 public:
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) = 0;
};

template<class R , typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6>
class Closure<R (A1, A2, A3, A4, A5, A6)> : public ClosureBase {
 public:
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) = 0;
};

template<bool Delete, class T>
class ConditionalAutoDeleter {
 public:
  ConditionalAutoDeleter(T *t) : t_(t) {}
  ~ConditionalAutoDeleter() {
    if (Delete) {
      delete t_;
    }
  }
 private:
  ConditionalAutoDeleter(const ConditionalAutoDeleter&);
  ConditionalAutoDeleter& operator= (const ConditionalAutoDeleter&);
  T *t_;
};

// Method Closures
//

// Specified for 0 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass>
class MethodClosure_0_0
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)();
 public:
  MethodClosure_0_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_0_0> deleter(this);
    return (object_->*method_)();
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)()) {
  return new MethodClosure_0_0<false, R, Klass, MethodKlass>(
      object, method);
}

template<class R, class Klass, class MethodKlass>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)()) {
  return new MethodClosure_0_0<true, R, Klass, MethodKlass>(
      object, method);
}

// Specified for 1 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1>
class MethodClosure_1_0
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(Arg1);
 public:
  MethodClosure_1_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_1_0> deleter(this);
    return (object_->*method_)(a1);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1)) {
  return new MethodClosure_1_0<false, R, Klass, MethodKlass, Arg1>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1)) {
  return new MethodClosure_1_0<true, R, Klass, MethodKlass, Arg1>(
      object, method);
}

// Specified for 1 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1>
class MethodClosure_1_1
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1);
 public:
  MethodClosure_1_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_1_1> deleter(this);
    return (object_->*method_)(b1_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1), BindArg1 b1) {
  return new MethodClosure_1_1<false, R, Klass, MethodKlass, BindArg1>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1), BindArg1 b1) {
  return new MethodClosure_1_1<true, R, Klass, MethodKlass, BindArg1>(
      object, method, b1);
}

// Specified for 2 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2>
class MethodClosure_2_0
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2);
 public:
  MethodClosure_2_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_2_0> deleter(this);
    return (object_->*method_)(a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2)) {
  return new MethodClosure_2_0<false, R, Klass, MethodKlass, Arg1, Arg2>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2)) {
  return new MethodClosure_2_0<true, R, Klass, MethodKlass, Arg1, Arg2>(
      object, method);
}

// Specified for 2 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1>
class MethodClosure_2_1
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1);
 public:
  MethodClosure_2_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_2_1> deleter(this);
    return (object_->*method_)(b1_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1), BindArg1 b1) {
  return new MethodClosure_2_1<false, R, Klass, MethodKlass, BindArg1, Arg1>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1), BindArg1 b1) {
  return new MethodClosure_2_1<true, R, Klass, MethodKlass, BindArg1, Arg1>(
      object, method, b1);
}

// Specified for 2 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2>
class MethodClosure_2_2
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2);
 public:
  MethodClosure_2_2 (Klass *object, MethodType method, BindArg1 b1, BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_2_2> deleter(this);
    return (object_->*method_)(b1_, b2_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2), BindArg1 b1,
        BindArg2 b2) {
  return new MethodClosure_2_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2), BindArg1 b1,
        BindArg2 b2) {
  return new MethodClosure_2_2<true, R, Klass, MethodKlass, BindArg1, BindArg2>(
      object, method, b1, b2);
}

// Specified for 3 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2, typename Arg3>
class MethodClosure_3_0
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2, Arg3);
 public:
  MethodClosure_3_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_3_0> deleter(this);
    return (object_->*method_)(a1, a2, a3);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3)) {
  return new MethodClosure_3_0<false, R, Klass, MethodKlass, Arg1, Arg2, Arg3>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3)) {
  return new MethodClosure_3_0<true, R, Klass, MethodKlass, Arg1, Arg2, Arg3>(
      object, method);
}

// Specified for 3 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1, typename Arg2>
class MethodClosure_3_1
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1, Arg2);
 public:
  MethodClosure_3_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_3_1> deleter(this);
    return (object_->*method_)(b1_ , a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2),
        BindArg1 b1) {
  return new MethodClosure_3_1<false, R, Klass, MethodKlass, BindArg1, Arg1,
      Arg2>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2),
        BindArg1 b1) {
  return new MethodClosure_3_1<true, R, Klass, MethodKlass, BindArg1, Arg1,
      Arg2>(
      object, method, b1);
}

// Specified for 3 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename Arg1>
class MethodClosure_3_2
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2 , Arg1);
 public:
  MethodClosure_3_2 (Klass *object, MethodType method, BindArg1 b1, BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_3_2> deleter(this);
    return (object_->*method_)(b1_, b2_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1),
        BindArg1 b1, BindArg2 b2) {
  return new MethodClosure_3_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1),
        BindArg1 b1, BindArg2 b2) {
  return new MethodClosure_3_2<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      Arg1>(
      object, method, b1, b2);
}

// Specified for 3 arguments (with 3 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3>
class MethodClosure_3_3
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3);
 public:
  MethodClosure_3_3 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_3_3> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3),
        BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new MethodClosure_3_3<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3>(
      object, method, b1, b2, b3);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3),
        BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new MethodClosure_3_3<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3>(
      object, method, b1, b2, b3);
}

// Specified for 4 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class MethodClosure_4_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
 public:
  MethodClosure_4_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_4_0> deleter(this);
    return (object_->*method_)(a1, a2, a3, a4);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4)) {
  return new MethodClosure_4_0<false, R, Klass, MethodKlass, Arg1, Arg2, Arg3,
      Arg4>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4)) {
  return new MethodClosure_4_0<true, R, Klass, MethodKlass, Arg1, Arg2, Arg3,
      Arg4>(
      object, method);
}

// Specified for 4 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1, typename Arg2, typename Arg3>
class MethodClosure_4_1
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1, Arg2, Arg3);
 public:
  MethodClosure_4_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_4_1> deleter(this);
    return (object_->*method_)(b1_ , a1, a2, a3);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3),
        BindArg1 b1) {
  return new MethodClosure_4_1<false, R, Klass, MethodKlass, BindArg1, Arg1,
      Arg2, Arg3>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3),
        BindArg1 b1) {
  return new MethodClosure_4_1<true, R, Klass, MethodKlass, BindArg1, Arg1,
      Arg2, Arg3>(
      object, method, b1);
}

// Specified for 4 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename Arg1, typename Arg2>
class MethodClosure_4_2
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2 , Arg1, Arg2);
 public:
  MethodClosure_4_2 (Klass *object, MethodType method, BindArg1 b1, BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_4_2> deleter(this);
    return (object_->*method_)(b1_, b2_ , a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2),
        BindArg1 b1, BindArg2 b2) {
  return new MethodClosure_4_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2),
        BindArg1 b1, BindArg2 b2) {
  return new MethodClosure_4_2<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      Arg1, Arg2>(
      object, method, b1, b2);
}

// Specified for 4 arguments (with 3 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename Arg1>
class MethodClosure_4_3
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3 , Arg1);
 public:
  MethodClosure_4_3 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_4_3> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1), BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new MethodClosure_4_3<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1>(
      object, method, b1, b2, b3);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1), BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new MethodClosure_4_3<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, Arg1>(
      object, method, b1, b2, b3);
}

// Specified for 4 arguments (with 4 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4>
class MethodClosure_4_4
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4);
 public:
  MethodClosure_4_4 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_4_4> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4), BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new MethodClosure_4_4<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4>(
      object, method, b1, b2, b3, b4);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4), BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new MethodClosure_4_4<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, BindArg4>(
      object, method, b1, b2, b3, b4);
}

// Specified for 5 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
class MethodClosure_5_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
 public:
  MethodClosure_5_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_5_0> deleter(this);
    return (object_->*method_)(a1, a2, a3, a4, a5);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return new MethodClosure_5_0<false, R, Klass, MethodKlass, Arg1, Arg2, Arg3,
      Arg4, Arg5>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return new MethodClosure_5_0<true, R, Klass, MethodKlass, Arg1, Arg2, Arg3,
      Arg4, Arg5>(
      object, method);
}

// Specified for 5 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
class MethodClosure_5_1
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1, Arg2, Arg3, Arg4);
 public:
  MethodClosure_5_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_5_1> deleter(this);
    return (object_->*method_)(b1_ , a1, a2, a3, a4);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3, Arg4),
        BindArg1 b1) {
  return new MethodClosure_5_1<false, R, Klass, MethodKlass, BindArg1, Arg1,
      Arg2, Arg3, Arg4>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3, Arg4),
        BindArg1 b1) {
  return new MethodClosure_5_1<true, R, Klass, MethodKlass, BindArg1, Arg1,
      Arg2, Arg3, Arg4>(
      object, method, b1);
}

// Specified for 5 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename Arg1, typename Arg2,
    typename Arg3>
class MethodClosure_5_2
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2 , Arg1, Arg2, Arg3);
 public:
  MethodClosure_5_2 (Klass *object, MethodType method, BindArg1 b1, BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_5_2> deleter(this);
    return (object_->*method_)(b1_, b2_ , a1, a2, a3);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2,
        Arg3), BindArg1 b1, BindArg2 b2) {
  return new MethodClosure_5_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2, Arg3>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2,
        Arg3), BindArg1 b1, BindArg2 b2) {
  return new MethodClosure_5_2<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      Arg1, Arg2, Arg3>(
      object, method, b1, b2);
}

// Specified for 5 arguments (with 3 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename Arg1,
    typename Arg2>
class MethodClosure_5_3
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3 , Arg1,
      Arg2);
 public:
  MethodClosure_5_3 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_5_3> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_ , a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1, Arg2), BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new MethodClosure_5_3<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1, Arg2>(
      object, method, b1, b2, b3);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1, Arg2), BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new MethodClosure_5_3<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, Arg1, Arg2>(
      object, method, b1, b2, b3);
}

// Specified for 5 arguments (with 4 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename Arg1>
class MethodClosure_5_4
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4 ,
      Arg1);
 public:
  MethodClosure_5_4 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_5_4> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4 , Arg1), BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new MethodClosure_5_4<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, Arg1>(
      object, method, b1, b2, b3, b4);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4 , Arg1), BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new MethodClosure_5_4<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, BindArg4, Arg1>(
      object, method, b1, b2, b3, b4);
}

// Specified for 5 arguments (with 5 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename BindArg5>
class MethodClosure_5_5
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4,
      BindArg5);
 public:
  MethodClosure_5_5 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_5_5> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_, b5_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5), BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4, BindArg5 b5) {
  return new MethodClosure_5_5<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5>(
      object, method, b1, b2, b3, b4, b5);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5), BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4, BindArg5 b5) {
  return new MethodClosure_5_5<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, BindArg4, BindArg5>(
      object, method, b1, b2, b3, b4, b5);
}

// Specified for 6 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename Arg6>
class MethodClosure_6_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
 public:
  MethodClosure_6_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_6_0> deleter(this);
    return (object_->*method_)(a1, a2, a3, a4, a5, a6);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
        Arg6)) {
  return new MethodClosure_6_0<false, R, Klass, MethodKlass, Arg1, Arg2, Arg3,
      Arg4, Arg5, Arg6>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
        Arg6)) {
  return new MethodClosure_6_0<true, R, Klass, MethodKlass, Arg1, Arg2, Arg3,
      Arg4, Arg5, Arg6>(
      object, method);
}

// Specified for 6 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
class MethodClosure_6_1
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1, Arg2, Arg3, Arg4, Arg5);
 public:
  MethodClosure_6_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_6_1> deleter(this);
    return (object_->*method_)(b1_ , a1, a2, a3, a4, a5);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3, Arg4,
        Arg5), BindArg1 b1) {
  return new MethodClosure_6_1<false, R, Klass, MethodKlass, BindArg1, Arg1,
      Arg2, Arg3, Arg4, Arg5>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3, Arg4,
        Arg5), BindArg1 b1) {
  return new MethodClosure_6_1<true, R, Klass, MethodKlass, BindArg1, Arg1,
      Arg2, Arg3, Arg4, Arg5>(
      object, method, b1);
}

// Specified for 6 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4>
class MethodClosure_6_2
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2 , Arg1, Arg2, Arg3,
      Arg4);
 public:
  MethodClosure_6_2 (Klass *object, MethodType method, BindArg1 b1, BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_6_2> deleter(this);
    return (object_->*method_)(b1_, b2_ , a1, a2, a3, a4);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2,
        Arg3, Arg4), BindArg1 b1, BindArg2 b2) {
  return new MethodClosure_6_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2, Arg3, Arg4>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2,
        Arg3, Arg4), BindArg1 b1, BindArg2 b2) {
  return new MethodClosure_6_2<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      Arg1, Arg2, Arg3, Arg4>(
      object, method, b1, b2);
}

// Specified for 6 arguments (with 3 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename Arg1,
    typename Arg2, typename Arg3>
class MethodClosure_6_3
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3 , Arg1,
      Arg2, Arg3);
 public:
  MethodClosure_6_3 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_6_3> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_ , a1, a2, a3);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1, Arg2, Arg3), BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new MethodClosure_6_3<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1, Arg2, Arg3>(
      object, method, b1, b2, b3);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1, Arg2, Arg3), BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new MethodClosure_6_3<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, Arg1, Arg2, Arg3>(
      object, method, b1, b2, b3);
}

// Specified for 6 arguments (with 4 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename Arg1, typename Arg2>
class MethodClosure_6_4
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4 ,
      Arg1, Arg2);
 public:
  MethodClosure_6_4 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_6_4> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_ , a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename Arg1,
    typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4 , Arg1, Arg2), BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4) {
  return new MethodClosure_6_4<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, Arg1, Arg2>(
      object, method, b1, b2, b3, b4);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename Arg1,
    typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4 , Arg1, Arg2), BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4) {
  return new MethodClosure_6_4<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, BindArg4, Arg1, Arg2>(
      object, method, b1, b2, b3, b4);
}

// Specified for 6 arguments (with 5 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename BindArg5, typename Arg1>
class MethodClosure_6_5
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4,
      BindArg5 , Arg1);
 public:
  MethodClosure_6_5 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_6_5> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_, b5_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5,
    typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5 , Arg1), BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4, BindArg5 b5) {
  return new MethodClosure_6_5<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5, Arg1>(
      object, method, b1, b2, b3, b4, b5);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5,
    typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5 , Arg1), BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4, BindArg5 b5) {
  return new MethodClosure_6_5<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, BindArg4, BindArg5, Arg1>(
      object, method, b1, b2, b3, b4, b5);
}

// Specified for 6 arguments (with 6 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename BindArg5, typename BindArg6>
class MethodClosure_6_6
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4,
      BindArg5, BindArg6);
 public:
  MethodClosure_6_6 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5, BindArg6 b6)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5), b6_(b6) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, MethodClosure_6_6> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_, b5_, b6_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
  BindArg6 b6_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5,
    typename BindArg6>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5, BindArg6), BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4, BindArg5 b5, BindArg6 b6) {
  return new MethodClosure_6_6<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5, BindArg6>(
      object, method, b1, b2, b3, b4, b5, b6);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5,
    typename BindArg6>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5, BindArg6), BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4, BindArg5 b5, BindArg6 b6) {
  return new MethodClosure_6_6<true, R, Klass, MethodKlass, BindArg1, BindArg2,
      BindArg3, BindArg4, BindArg5, BindArg6>(
      object, method, b1, b2, b3, b4, b5, b6);
}

// Const Method Closures
//

// Specified for 0 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass>
class ConstMethodClosure_0_0
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)() const;
 public:
  ConstMethodClosure_0_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_0_0> deleter(this);
    return (object_->*method_)();
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)() const) {
  return new ConstMethodClosure_0_0<false, R, Klass, MethodKlass>(
      object, method);
}

template<class R, class Klass, class MethodKlass>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)() const) {
  return new ConstMethodClosure_0_0<true, R, Klass, MethodKlass>(
      object, method);
}

// Specified for 1 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1>
class ConstMethodClosure_1_0
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(Arg1) const;
 public:
  ConstMethodClosure_1_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_1_0> deleter(this);
    return (object_->*method_)(a1);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1) const) {
  return new ConstMethodClosure_1_0<false, R, Klass, MethodKlass, Arg1>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1) const) {
  return new ConstMethodClosure_1_0<true, R, Klass, MethodKlass, Arg1>(
      object, method);
}

// Specified for 1 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1>
class ConstMethodClosure_1_1
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1) const;
 public:
  ConstMethodClosure_1_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_1_1> deleter(this);
    return (object_->*method_)(b1_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1) const, BindArg1 b1) {
  return new ConstMethodClosure_1_1<false, R, Klass, MethodKlass, BindArg1>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1) const, BindArg1 b1) {
  return new ConstMethodClosure_1_1<true, R, Klass, MethodKlass, BindArg1>(
      object, method, b1);
}

// Specified for 2 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2>
class ConstMethodClosure_2_0
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2) const;
 public:
  ConstMethodClosure_2_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_2_0> deleter(this);
    return (object_->*method_)(a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2) const) {
  return new ConstMethodClosure_2_0<false, R, Klass, MethodKlass, Arg1, Arg2>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2) const) {
  return new ConstMethodClosure_2_0<true, R, Klass, MethodKlass, Arg1, Arg2>(
      object, method);
}

// Specified for 2 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1>
class ConstMethodClosure_2_1
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1) const;
 public:
  ConstMethodClosure_2_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_2_1> deleter(this);
    return (object_->*method_)(b1_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1) const,
        BindArg1 b1) {
  return new ConstMethodClosure_2_1<false, R, Klass, MethodKlass, BindArg1,
      Arg1>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1) const,
        BindArg1 b1) {
  return new ConstMethodClosure_2_1<true, R, Klass, MethodKlass, BindArg1,
      Arg1>(
      object, method, b1);
}

// Specified for 2 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2>
class ConstMethodClosure_2_2
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2) const;
 public:
  ConstMethodClosure_2_2 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_2_2> deleter(this);
    return (object_->*method_)(b1_, b2_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2) const,
        BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_2_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2) const,
        BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_2_2<true, R, Klass, MethodKlass, BindArg1,
      BindArg2>(
      object, method, b1, b2);
}

// Specified for 3 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2, typename Arg3>
class ConstMethodClosure_3_0
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2, Arg3) const;
 public:
  ConstMethodClosure_3_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_3_0> deleter(this);
    return (object_->*method_)(a1, a2, a3);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3) const) {
  return new ConstMethodClosure_3_0<false, R, Klass, MethodKlass, Arg1, Arg2,
      Arg3>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3) const) {
  return new ConstMethodClosure_3_0<true, R, Klass, MethodKlass, Arg1, Arg2,
      Arg3>(
      object, method);
}

// Specified for 3 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1, typename Arg2>
class ConstMethodClosure_3_1
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1, Arg2) const;
 public:
  ConstMethodClosure_3_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_3_1> deleter(this);
    return (object_->*method_)(b1_ , a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2) const,
        BindArg1 b1) {
  return new ConstMethodClosure_3_1<false, R, Klass, MethodKlass, BindArg1,
      Arg1, Arg2>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2) const,
        BindArg1 b1) {
  return new ConstMethodClosure_3_1<true, R, Klass, MethodKlass, BindArg1,
      Arg1, Arg2>(
      object, method, b1);
}

// Specified for 3 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename Arg1>
class ConstMethodClosure_3_2
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2 , Arg1) const;
 public:
  ConstMethodClosure_3_2 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_3_2> deleter(this);
    return (object_->*method_)(b1_, b2_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1) const,
        BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_3_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1) const,
        BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_3_2<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1>(
      object, method, b1, b2);
}

// Specified for 3 arguments (with 3 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3>
class ConstMethodClosure_3_3
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3) const;
 public:
  ConstMethodClosure_3_3 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_3_3> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2,
        BindArg3) const, BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new ConstMethodClosure_3_3<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3>(
      object, method, b1, b2, b3);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2,
        BindArg3) const, BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new ConstMethodClosure_3_3<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3>(
      object, method, b1, b2, b3);
}

// Specified for 4 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class ConstMethodClosure_4_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2, Arg3, Arg4) const;
 public:
  ConstMethodClosure_4_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_4_0> deleter(this);
    return (object_->*method_)(a1, a2, a3, a4);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4) const) {
  return new ConstMethodClosure_4_0<false, R, Klass, MethodKlass, Arg1, Arg2,
      Arg3, Arg4>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4) const) {
  return new ConstMethodClosure_4_0<true, R, Klass, MethodKlass, Arg1, Arg2,
      Arg3, Arg4>(
      object, method);
}

// Specified for 4 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1, typename Arg2, typename Arg3>
class ConstMethodClosure_4_1
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1, Arg2, Arg3) const;
 public:
  ConstMethodClosure_4_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_4_1> deleter(this);
    return (object_->*method_)(b1_ , a1, a2, a3);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3) const,
        BindArg1 b1) {
  return new ConstMethodClosure_4_1<false, R, Klass, MethodKlass, BindArg1,
      Arg1, Arg2, Arg3>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3) const,
        BindArg1 b1) {
  return new ConstMethodClosure_4_1<true, R, Klass, MethodKlass, BindArg1,
      Arg1, Arg2, Arg3>(
      object, method, b1);
}

// Specified for 4 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename Arg1, typename Arg2>
class ConstMethodClosure_4_2
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2 , Arg1, Arg2) const;
 public:
  ConstMethodClosure_4_2 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_4_2> deleter(this);
    return (object_->*method_)(b1_, b2_ , a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1,
        Arg2) const, BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_4_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1,
        Arg2) const, BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_4_2<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2>(
      object, method, b1, b2);
}

// Specified for 4 arguments (with 3 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename Arg1>
class ConstMethodClosure_4_3
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3 ,
      Arg1) const;
 public:
  ConstMethodClosure_4_3 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_4_3> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1) const, BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new ConstMethodClosure_4_3<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1>(
      object, method, b1, b2, b3);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1) const, BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new ConstMethodClosure_4_3<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1>(
      object, method, b1, b2, b3);
}

// Specified for 4 arguments (with 4 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4>
class ConstMethodClosure_4_4
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3,
      BindArg4) const;
 public:
  ConstMethodClosure_4_4 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_4_4> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4) const, BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new ConstMethodClosure_4_4<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4>(
      object, method, b1, b2, b3, b4);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4) const, BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new ConstMethodClosure_4_4<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4>(
      object, method, b1, b2, b3, b4);
}

// Specified for 5 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
class ConstMethodClosure_5_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5) const;
 public:
  ConstMethodClosure_5_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_5_0> deleter(this);
    return (object_->*method_)(a1, a2, a3, a4, a5);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4,
        Arg5) const) {
  return new ConstMethodClosure_5_0<false, R, Klass, MethodKlass, Arg1, Arg2,
      Arg3, Arg4, Arg5>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4,
        Arg5) const) {
  return new ConstMethodClosure_5_0<true, R, Klass, MethodKlass, Arg1, Arg2,
      Arg3, Arg4, Arg5>(
      object, method);
}

// Specified for 5 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
class ConstMethodClosure_5_1
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1, Arg2, Arg3, Arg4) const;
 public:
  ConstMethodClosure_5_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_5_1> deleter(this);
    return (object_->*method_)(b1_ , a1, a2, a3, a4);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3,
        Arg4) const, BindArg1 b1) {
  return new ConstMethodClosure_5_1<false, R, Klass, MethodKlass, BindArg1,
      Arg1, Arg2, Arg3, Arg4>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3,
        Arg4) const, BindArg1 b1) {
  return new ConstMethodClosure_5_1<true, R, Klass, MethodKlass, BindArg1,
      Arg1, Arg2, Arg3, Arg4>(
      object, method, b1);
}

// Specified for 5 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename Arg1, typename Arg2,
    typename Arg3>
class ConstMethodClosure_5_2
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2 , Arg1, Arg2,
      Arg3) const;
 public:
  ConstMethodClosure_5_2 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_5_2> deleter(this);
    return (object_->*method_)(b1_, b2_ , a1, a2, a3);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2,
        Arg3) const, BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_5_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2, Arg3>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2,
        Arg3) const, BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_5_2<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2, Arg3>(
      object, method, b1, b2);
}

// Specified for 5 arguments (with 3 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename Arg1,
    typename Arg2>
class ConstMethodClosure_5_3
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3 , Arg1,
      Arg2) const;
 public:
  ConstMethodClosure_5_3 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_5_3> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_ , a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1, Arg2) const, BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new ConstMethodClosure_5_3<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1, Arg2>(
      object, method, b1, b2, b3);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1, Arg2) const, BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new ConstMethodClosure_5_3<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1, Arg2>(
      object, method, b1, b2, b3);
}

// Specified for 5 arguments (with 4 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename Arg1>
class ConstMethodClosure_5_4
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4 ,
      Arg1) const;
 public:
  ConstMethodClosure_5_4 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_5_4> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4 , Arg1) const, BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4) {
  return new ConstMethodClosure_5_4<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, Arg1>(
      object, method, b1, b2, b3, b4);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4 , Arg1) const, BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4) {
  return new ConstMethodClosure_5_4<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, Arg1>(
      object, method, b1, b2, b3, b4);
}

// Specified for 5 arguments (with 5 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename BindArg5>
class ConstMethodClosure_5_5
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4,
      BindArg5) const;
 public:
  ConstMethodClosure_5_5 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_5_5> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_, b5_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5) const, BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4, BindArg5 b5) {
  return new ConstMethodClosure_5_5<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5>(
      object, method, b1, b2, b3, b4, b5);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5) const, BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4, BindArg5 b5) {
  return new ConstMethodClosure_5_5<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5>(
      object, method, b1, b2, b3, b4, b5);
}

// Specified for 6 arguments (with 0 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename Arg6>
class ConstMethodClosure_6_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)> {
  typedef R (MethodKlass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6) const;
 public:
  ConstMethodClosure_6_0 (Klass *object, MethodType method)
    : object_(object), method_(method)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_6_0> deleter(this);
    return (object_->*method_)(a1, a2, a3, a4, a5, a6);
  }
 private:
  Klass *object_;
  MethodType method_;
};

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
        Arg6) const) {
  return new ConstMethodClosure_6_0<false, R, Klass, MethodKlass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6>(
      object, method);
}

template<class R, class Klass, class MethodKlass, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
        Arg6) const) {
  return new ConstMethodClosure_6_0<true, R, Klass, MethodKlass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6>(
      object, method);
}

// Specified for 6 arguments (with 1 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
class ConstMethodClosure_6_1
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)> {
  typedef R (MethodKlass::*MethodType)(BindArg1 , Arg1, Arg2, Arg3, Arg4,
      Arg5) const;
 public:
  ConstMethodClosure_6_1 (Klass *object, MethodType method, BindArg1 b1)
    : object_(object), method_(method)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_6_1> deleter(this);
    return (object_->*method_)(b1_ , a1, a2, a3, a4, a5);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3, Arg4,
        Arg5) const, BindArg1 b1) {
  return new ConstMethodClosure_6_1<false, R, Klass, MethodKlass, BindArg1,
      Arg1, Arg2, Arg3, Arg4, Arg5>(
      object, method, b1);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1 , Arg1, Arg2, Arg3, Arg4,
        Arg5) const, BindArg1 b1) {
  return new ConstMethodClosure_6_1<true, R, Klass, MethodKlass, BindArg1,
      Arg1, Arg2, Arg3, Arg4, Arg5>(
      object, method, b1);
}

// Specified for 6 arguments (with 2 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4>
class ConstMethodClosure_6_2
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2 , Arg1, Arg2, Arg3,
      Arg4) const;
 public:
  ConstMethodClosure_6_2 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_6_2> deleter(this);
    return (object_->*method_)(b1_, b2_ , a1, a2, a3, a4);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2,
        Arg3, Arg4) const, BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_6_2<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2, Arg3, Arg4>(
      object, method, b1, b2);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2 , Arg1, Arg2,
        Arg3, Arg4) const, BindArg1 b1, BindArg2 b2) {
  return new ConstMethodClosure_6_2<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, Arg1, Arg2, Arg3, Arg4>(
      object, method, b1, b2);
}

// Specified for 6 arguments (with 3 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename Arg1,
    typename Arg2, typename Arg3>
class ConstMethodClosure_6_3
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3 , Arg1,
      Arg2, Arg3) const;
 public:
  ConstMethodClosure_6_3 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_6_3> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_ , a1, a2, a3);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1, Arg2, Arg3) const, BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new ConstMethodClosure_6_3<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1, Arg2, Arg3>(
      object, method, b1, b2, b3);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3 ,
        Arg1, Arg2, Arg3) const, BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new ConstMethodClosure_6_3<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, Arg1, Arg2, Arg3>(
      object, method, b1, b2, b3);
}

// Specified for 6 arguments (with 4 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename Arg1, typename Arg2>
class ConstMethodClosure_6_4
  : public Closure<R (Arg1, Arg2)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4 ,
      Arg1, Arg2) const;
 public:
  ConstMethodClosure_6_4 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_6_4> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_ , a1, a2);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename Arg1,
    typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4 , Arg1, Arg2) const, BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4) {
  return new ConstMethodClosure_6_4<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, Arg1, Arg2>(
      object, method, b1, b2, b3, b4);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename Arg1,
    typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4 , Arg1, Arg2) const, BindArg1 b1, BindArg2 b2, BindArg3 b3,
        BindArg4 b4) {
  return new ConstMethodClosure_6_4<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, Arg1, Arg2>(
      object, method, b1, b2, b3, b4);
}

// Specified for 6 arguments (with 5 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename BindArg5, typename Arg1>
class ConstMethodClosure_6_5
  : public Closure<R (Arg1)> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4,
      BindArg5 , Arg1) const;
 public:
  ConstMethodClosure_6_5 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_6_5> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_, b5_ , a1);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5,
    typename Arg1>
Closure<R (Arg1)>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5 , Arg1) const, BindArg1 b1, BindArg2 b2,
        BindArg3 b3, BindArg4 b4, BindArg5 b5) {
  return new ConstMethodClosure_6_5<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5, Arg1>(
      object, method, b1, b2, b3, b4, b5);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5,
    typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5 , Arg1) const, BindArg1 b1, BindArg2 b2,
        BindArg3 b3, BindArg4 b4, BindArg5 b5) {
  return new ConstMethodClosure_6_5<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5, Arg1>(
      object, method, b1, b2, b3, b4, b5);
}

// Specified for 6 arguments (with 6 bind-arguments)
template <bool Repeatable, class R, class Klass, class MethodKlass,
    typename BindArg1, typename BindArg2, typename BindArg3, typename BindArg4,
    typename BindArg5, typename BindArg6>
class ConstMethodClosure_6_6
  : public Closure<R ()> {
  typedef R (MethodKlass::*MethodType)(BindArg1, BindArg2, BindArg3, BindArg4,
      BindArg5, BindArg6) const;
 public:
  ConstMethodClosure_6_6 (Klass *object, MethodType method, BindArg1 b1,
      BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5, BindArg6 b6)
    : object_(object), method_(method)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5), b6_(b6) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, ConstMethodClosure_6_6> deleter(this);
    return (object_->*method_)(b1_, b2_, b3_, b4_, b5_, b6_);
  }
 private:
  Klass *object_;
  MethodType method_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
  BindArg6 b6_;
};

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5,
    typename BindArg6>
Closure<R ()>* NewClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5, BindArg6) const, BindArg1 b1, BindArg2 b2,
        BindArg3 b3, BindArg4 b4, BindArg5 b5, BindArg6 b6) {
  return new ConstMethodClosure_6_6<false, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5, BindArg6>(
      object, method, b1, b2, b3, b4, b5, b6);
}

template<class R, class Klass, class MethodKlass, typename BindArg1,
    typename BindArg2, typename BindArg3, typename BindArg4, typename BindArg5,
    typename BindArg6>
Closure<R ()>* NewPermanentClosure(
    Klass *object, R (MethodKlass::*method)(BindArg1, BindArg2, BindArg3,
        BindArg4, BindArg5, BindArg6) const, BindArg1 b1, BindArg2 b2,
        BindArg3 b3, BindArg4 b4, BindArg5 b5, BindArg6 b6) {
  return new ConstMethodClosure_6_6<true, R, Klass, MethodKlass, BindArg1,
      BindArg2, BindArg3, BindArg4, BindArg5, BindArg6>(
      object, method, b1, b2, b3, b4, b5, b6);
}

// Function Closures
//

// Specified for 0 arguments (with 0 bind-arguments)
template<bool Repeatable, class R>
class FunctionClosure_0_0
  : public Closure<R ()> {
  typedef R (*FunctionType)();
 public:
  FunctionClosure_0_0(FunctionType function)
    : function_(function)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_0_0> deleter(this);
    return (*function_)();
  }
 private:
  FunctionType function_;
};

template<class R>
Closure<R ()>* NewClosure(
    R (*function)()) {
  return new FunctionClosure_0_0<false, R>(
      function);
}

template<class R>
Closure<R ()>* NewPermanentClosure(
    R (*function)()) {
  return new FunctionClosure_0_0<true, R>(
      function);
}

// Specified for 1 arguments (with 0 bind-arguments)
template<bool Repeatable, class R, typename Arg1>
class FunctionClosure_1_0
  : public Closure<R (Arg1)> {
  typedef R (*FunctionType)(Arg1);
 public:
  FunctionClosure_1_0(FunctionType function)
    : function_(function)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_1_0> deleter(this);
    return (*function_)(a1);
  }
 private:
  FunctionType function_;
};

template<class R, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    R (*function)(Arg1)) {
  return new FunctionClosure_1_0<false, R, Arg1>(
      function);
}

template<class R, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    R (*function)(Arg1)) {
  return new FunctionClosure_1_0<true, R, Arg1>(
      function);
}

// Specified for 1 arguments (with 1 bind-arguments)
template<bool Repeatable, class R, typename BindArg1>
class FunctionClosure_1_1
  : public Closure<R ()> {
  typedef R (*FunctionType)(BindArg1);
 public:
  FunctionClosure_1_1(FunctionType function, BindArg1 b1)
    : function_(function)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_1_1> deleter(this);
    return (*function_)(b1_);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
};

template<class R, typename BindArg1>
Closure<R ()>* NewClosure(
    R (*function)(BindArg1), BindArg1 b1) {
  return new FunctionClosure_1_1<false, R, BindArg1>(
      function, b1);
}

template<class R, typename BindArg1>
Closure<R ()>* NewPermanentClosure(
    R (*function)(BindArg1), BindArg1 b1) {
  return new FunctionClosure_1_1<true, R, BindArg1>(
      function, b1);
}

// Specified for 2 arguments (with 0 bind-arguments)
template<bool Repeatable, class R, typename Arg1, typename Arg2>
class FunctionClosure_2_0
  : public Closure<R (Arg1, Arg2)> {
  typedef R (*FunctionType)(Arg1, Arg2);
 public:
  FunctionClosure_2_0(FunctionType function)
    : function_(function)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_2_0> deleter(this);
    return (*function_)(a1, a2);
  }
 private:
  FunctionType function_;
};

template<class R, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    R (*function)(Arg1, Arg2)) {
  return new FunctionClosure_2_0<false, R, Arg1, Arg2>(
      function);
}

template<class R, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    R (*function)(Arg1, Arg2)) {
  return new FunctionClosure_2_0<true, R, Arg1, Arg2>(
      function);
}

// Specified for 2 arguments (with 1 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename Arg1>
class FunctionClosure_2_1
  : public Closure<R (Arg1)> {
  typedef R (*FunctionType)(BindArg1 , Arg1);
 public:
  FunctionClosure_2_1(FunctionType function, BindArg1 b1)
    : function_(function)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_2_1> deleter(this);
    return (*function_)(b1_ , a1);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
};

template<class R, typename BindArg1, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    R (*function)(BindArg1 , Arg1), BindArg1 b1) {
  return new FunctionClosure_2_1<false, R, BindArg1, Arg1>(
      function, b1);
}

template<class R, typename BindArg1, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    R (*function)(BindArg1 , Arg1), BindArg1 b1) {
  return new FunctionClosure_2_1<true, R, BindArg1, Arg1>(
      function, b1);
}

// Specified for 2 arguments (with 2 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2>
class FunctionClosure_2_2
  : public Closure<R ()> {
  typedef R (*FunctionType)(BindArg1, BindArg2);
 public:
  FunctionClosure_2_2(FunctionType function, BindArg1 b1, BindArg2 b2)
    : function_(function)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_2_2> deleter(this);
    return (*function_)(b1_, b2_);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, typename BindArg1, typename BindArg2>
Closure<R ()>* NewClosure(
    R (*function)(BindArg1, BindArg2), BindArg1 b1, BindArg2 b2) {
  return new FunctionClosure_2_2<false, R, BindArg1, BindArg2>(
      function, b1, b2);
}

template<class R, typename BindArg1, typename BindArg2>
Closure<R ()>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2), BindArg1 b1, BindArg2 b2) {
  return new FunctionClosure_2_2<true, R, BindArg1, BindArg2>(
      function, b1, b2);
}

// Specified for 3 arguments (with 0 bind-arguments)
template<bool Repeatable, class R, typename Arg1, typename Arg2, typename Arg3>
class FunctionClosure_3_0
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3);
 public:
  FunctionClosure_3_0(FunctionType function)
    : function_(function)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_3_0> deleter(this);
    return (*function_)(a1, a2, a3);
  }
 private:
  FunctionType function_;
};

template<class R, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    R (*function)(Arg1, Arg2, Arg3)) {
  return new FunctionClosure_3_0<false, R, Arg1, Arg2, Arg3>(
      function);
}

template<class R, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    R (*function)(Arg1, Arg2, Arg3)) {
  return new FunctionClosure_3_0<true, R, Arg1, Arg2, Arg3>(
      function);
}

// Specified for 3 arguments (with 1 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename Arg1,
    typename Arg2>
class FunctionClosure_3_1
  : public Closure<R (Arg1, Arg2)> {
  typedef R (*FunctionType)(BindArg1 , Arg1, Arg2);
 public:
  FunctionClosure_3_1(FunctionType function, BindArg1 b1)
    : function_(function)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_3_1> deleter(this);
    return (*function_)(b1_ , a1, a2);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
};

template<class R, typename BindArg1, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    R (*function)(BindArg1 , Arg1, Arg2), BindArg1 b1) {
  return new FunctionClosure_3_1<false, R, BindArg1, Arg1, Arg2>(
      function, b1);
}

template<class R, typename BindArg1, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    R (*function)(BindArg1 , Arg1, Arg2), BindArg1 b1) {
  return new FunctionClosure_3_1<true, R, BindArg1, Arg1, Arg2>(
      function, b1);
}

// Specified for 3 arguments (with 2 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename Arg1>
class FunctionClosure_3_2
  : public Closure<R (Arg1)> {
  typedef R (*FunctionType)(BindArg1, BindArg2 , Arg1);
 public:
  FunctionClosure_3_2(FunctionType function, BindArg1 b1, BindArg2 b2)
    : function_(function)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_3_2> deleter(this);
    return (*function_)(b1_, b2_ , a1);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, typename BindArg1, typename BindArg2, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    R (*function)(BindArg1, BindArg2 , Arg1), BindArg1 b1, BindArg2 b2) {
  return new FunctionClosure_3_2<false, R, BindArg1, BindArg2, Arg1>(
      function, b1, b2);
}

template<class R, typename BindArg1, typename BindArg2, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2 , Arg1), BindArg1 b1, BindArg2 b2) {
  return new FunctionClosure_3_2<true, R, BindArg1, BindArg2, Arg1>(
      function, b1, b2);
}

// Specified for 3 arguments (with 3 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3>
class FunctionClosure_3_3
  : public Closure<R ()> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3);
 public:
  FunctionClosure_3_3(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_3_3> deleter(this);
    return (*function_)(b1_, b2_, b3_);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3>
Closure<R ()>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3), BindArg1 b1, BindArg2 b2,
        BindArg3 b3) {
  return new FunctionClosure_3_3<false, R, BindArg1, BindArg2, BindArg3>(
      function, b1, b2, b3);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3>
Closure<R ()>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3), BindArg1 b1, BindArg2 b2,
        BindArg3 b3) {
  return new FunctionClosure_3_3<true, R, BindArg1, BindArg2, BindArg3>(
      function, b1, b2, b3);
}

// Specified for 4 arguments (with 0 bind-arguments)
template<bool Repeatable, class R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
class FunctionClosure_4_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
 public:
  FunctionClosure_4_0(FunctionType function)
    : function_(function)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_4_0> deleter(this);
    return (*function_)(a1, a2, a3, a4);
  }
 private:
  FunctionType function_;
};

template<class R, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    R (*function)(Arg1, Arg2, Arg3, Arg4)) {
  return new FunctionClosure_4_0<false, R, Arg1, Arg2, Arg3, Arg4>(
      function);
}

template<class R, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    R (*function)(Arg1, Arg2, Arg3, Arg4)) {
  return new FunctionClosure_4_0<true, R, Arg1, Arg2, Arg3, Arg4>(
      function);
}

// Specified for 4 arguments (with 1 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename Arg1,
    typename Arg2, typename Arg3>
class FunctionClosure_4_1
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (*FunctionType)(BindArg1 , Arg1, Arg2, Arg3);
 public:
  FunctionClosure_4_1(FunctionType function, BindArg1 b1)
    : function_(function)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_4_1> deleter(this);
    return (*function_)(b1_ , a1, a2, a3);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
};

template<class R, typename BindArg1, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    R (*function)(BindArg1 , Arg1, Arg2, Arg3), BindArg1 b1) {
  return new FunctionClosure_4_1<false, R, BindArg1, Arg1, Arg2, Arg3>(
      function, b1);
}

template<class R, typename BindArg1, typename Arg1, typename Arg2,
    typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    R (*function)(BindArg1 , Arg1, Arg2, Arg3), BindArg1 b1) {
  return new FunctionClosure_4_1<true, R, BindArg1, Arg1, Arg2, Arg3>(
      function, b1);
}

// Specified for 4 arguments (with 2 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename Arg1, typename Arg2>
class FunctionClosure_4_2
  : public Closure<R (Arg1, Arg2)> {
  typedef R (*FunctionType)(BindArg1, BindArg2 , Arg1, Arg2);
 public:
  FunctionClosure_4_2(FunctionType function, BindArg1 b1, BindArg2 b2)
    : function_(function)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_4_2> deleter(this);
    return (*function_)(b1_, b2_ , a1, a2);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, typename BindArg1, typename BindArg2, typename Arg1,
    typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    R (*function)(BindArg1, BindArg2 , Arg1, Arg2), BindArg1 b1, BindArg2 b2) {
  return new FunctionClosure_4_2<false, R, BindArg1, BindArg2, Arg1, Arg2>(
      function, b1, b2);
}

template<class R, typename BindArg1, typename BindArg2, typename Arg1,
    typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2 , Arg1, Arg2), BindArg1 b1, BindArg2 b2) {
  return new FunctionClosure_4_2<true, R, BindArg1, BindArg2, Arg1, Arg2>(
      function, b1, b2);
}

// Specified for 4 arguments (with 3 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename Arg1>
class FunctionClosure_4_3
  : public Closure<R (Arg1)> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3 , Arg1);
 public:
  FunctionClosure_4_3(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_4_3> deleter(this);
    return (*function_)(b1_, b2_, b3_ , a1);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename Arg1>
Closure<R (Arg1)>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3 , Arg1), BindArg1 b1,
        BindArg2 b2, BindArg3 b3) {
  return new FunctionClosure_4_3<false, R, BindArg1, BindArg2, BindArg3, Arg1>(
      function, b1, b2, b3);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3 , Arg1), BindArg1 b1,
        BindArg2 b2, BindArg3 b3) {
  return new FunctionClosure_4_3<true, R, BindArg1, BindArg2, BindArg3, Arg1>(
      function, b1, b2, b3);
}

// Specified for 4 arguments (with 4 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename BindArg4>
class FunctionClosure_4_4
  : public Closure<R ()> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3, BindArg4);
 public:
  FunctionClosure_4_4(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3, BindArg4 b4)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_4_4> deleter(this);
    return (*function_)(b1_, b2_, b3_, b4_);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4>
Closure<R ()>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4), BindArg1 b1,
        BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new FunctionClosure_4_4<false, R, BindArg1, BindArg2, BindArg3,
      BindArg4>(
      function, b1, b2, b3, b4);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4>
Closure<R ()>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4), BindArg1 b1,
        BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new FunctionClosure_4_4<true, R, BindArg1, BindArg2, BindArg3,
      BindArg4>(
      function, b1, b2, b3, b4);
}

// Specified for 5 arguments (with 0 bind-arguments)
template<bool Repeatable, class R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
class FunctionClosure_5_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
 public:
  FunctionClosure_5_0(FunctionType function)
    : function_(function)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_5_0> deleter(this);
    return (*function_)(a1, a2, a3, a4, a5);
  }
 private:
  FunctionType function_;
};

template<class R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
    typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewClosure(
    R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return new FunctionClosure_5_0<false, R, Arg1, Arg2, Arg3, Arg4, Arg5>(
      function);
}

template<class R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
    typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewPermanentClosure(
    R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return new FunctionClosure_5_0<true, R, Arg1, Arg2, Arg3, Arg4, Arg5>(
      function);
}

// Specified for 5 arguments (with 1 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
class FunctionClosure_5_1
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (*FunctionType)(BindArg1 , Arg1, Arg2, Arg3, Arg4);
 public:
  FunctionClosure_5_1(FunctionType function, BindArg1 b1)
    : function_(function)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_5_1> deleter(this);
    return (*function_)(b1_ , a1, a2, a3, a4);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
};

template<class R, typename BindArg1, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    R (*function)(BindArg1 , Arg1, Arg2, Arg3, Arg4), BindArg1 b1) {
  return new FunctionClosure_5_1<false, R, BindArg1, Arg1, Arg2, Arg3, Arg4>(
      function, b1);
}

template<class R, typename BindArg1, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    R (*function)(BindArg1 , Arg1, Arg2, Arg3, Arg4), BindArg1 b1) {
  return new FunctionClosure_5_1<true, R, BindArg1, Arg1, Arg2, Arg3, Arg4>(
      function, b1);
}

// Specified for 5 arguments (with 2 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename Arg1, typename Arg2, typename Arg3>
class FunctionClosure_5_2
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (*FunctionType)(BindArg1, BindArg2 , Arg1, Arg2, Arg3);
 public:
  FunctionClosure_5_2(FunctionType function, BindArg1 b1, BindArg2 b2)
    : function_(function)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_5_2> deleter(this);
    return (*function_)(b1_, b2_ , a1, a2, a3);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, typename BindArg1, typename BindArg2, typename Arg1,
    typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    R (*function)(BindArg1, BindArg2 , Arg1, Arg2, Arg3), BindArg1 b1,
        BindArg2 b2) {
  return new FunctionClosure_5_2<false, R, BindArg1, BindArg2, Arg1, Arg2,
      Arg3>(
      function, b1, b2);
}

template<class R, typename BindArg1, typename BindArg2, typename Arg1,
    typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2 , Arg1, Arg2, Arg3), BindArg1 b1,
        BindArg2 b2) {
  return new FunctionClosure_5_2<true, R, BindArg1, BindArg2, Arg1, Arg2, Arg3>(
      function, b1, b2);
}

// Specified for 5 arguments (with 3 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename Arg1, typename Arg2>
class FunctionClosure_5_3
  : public Closure<R (Arg1, Arg2)> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3 , Arg1, Arg2);
 public:
  FunctionClosure_5_3(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_5_3> deleter(this);
    return (*function_)(b1_, b2_, b3_ , a1, a2);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3 , Arg1, Arg2), BindArg1 b1,
        BindArg2 b2, BindArg3 b3) {
  return new FunctionClosure_5_3<false, R, BindArg1, BindArg2, BindArg3, Arg1,
      Arg2>(
      function, b1, b2, b3);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3 , Arg1, Arg2), BindArg1 b1,
        BindArg2 b2, BindArg3 b3) {
  return new FunctionClosure_5_3<true, R, BindArg1, BindArg2, BindArg3, Arg1,
      Arg2>(
      function, b1, b2, b3);
}

// Specified for 5 arguments (with 4 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename BindArg4, typename Arg1>
class FunctionClosure_5_4
  : public Closure<R (Arg1)> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3, BindArg4 , Arg1);
 public:
  FunctionClosure_5_4(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3, BindArg4 b4)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_5_4> deleter(this);
    return (*function_)(b1_, b2_, b3_, b4_ , a1);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4 , Arg1), BindArg1 b1,
        BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new FunctionClosure_5_4<false, R, BindArg1, BindArg2, BindArg3,
      BindArg4, Arg1>(
      function, b1, b2, b3, b4);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4 , Arg1), BindArg1 b1,
        BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new FunctionClosure_5_4<true, R, BindArg1, BindArg2, BindArg3,
      BindArg4, Arg1>(
      function, b1, b2, b3, b4);
}

// Specified for 5 arguments (with 5 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename BindArg4, typename BindArg5>
class FunctionClosure_5_5
  : public Closure<R ()> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5);
 public:
  FunctionClosure_5_5(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3, BindArg4 b4, BindArg5 b5)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_5_5> deleter(this);
    return (*function_)(b1_, b2_, b3_, b4_, b5_);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename BindArg5>
Closure<R ()>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5),
        BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5) {
  return new FunctionClosure_5_5<false, R, BindArg1, BindArg2, BindArg3,
      BindArg4, BindArg5>(
      function, b1, b2, b3, b4, b5);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename BindArg5>
Closure<R ()>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5),
        BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5) {
  return new FunctionClosure_5_5<true, R, BindArg1, BindArg2, BindArg3,
      BindArg4, BindArg5>(
      function, b1, b2, b3, b4, b5);
}

// Specified for 6 arguments (with 0 bind-arguments)
template<bool Repeatable, class R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6>
class FunctionClosure_6_0
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)> {
  typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
 public:
  FunctionClosure_6_0(FunctionType function)
    : function_(function)
     {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5, Arg6 a6) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_6_0> deleter(this);
    return (*function_)(a1, a2, a3, a4, a5, a6);
  }
 private:
  FunctionType function_;
};

template<class R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
    typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* NewClosure(
    R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
  return new FunctionClosure_6_0<false, R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>(
      function);
}

template<class R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
    typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* NewPermanentClosure(
    R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
  return new FunctionClosure_6_0<true, R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>(
      function);
}

// Specified for 6 arguments (with 1 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5>
class FunctionClosure_6_1
  : public Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)> {
  typedef R (*FunctionType)(BindArg1 , Arg1, Arg2, Arg3, Arg4, Arg5);
 public:
  FunctionClosure_6_1(FunctionType function, BindArg1 b1)
    : function_(function)
    , b1_(b1) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_6_1> deleter(this);
    return (*function_)(b1_ , a1, a2, a3, a4, a5);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
};

template<class R, typename BindArg1, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewClosure(
    R (*function)(BindArg1 , Arg1, Arg2, Arg3, Arg4, Arg5), BindArg1 b1) {
  return new FunctionClosure_6_1<false, R, BindArg1, Arg1, Arg2, Arg3, Arg4,
      Arg5>(
      function, b1);
}

template<class R, typename BindArg1, typename Arg1, typename Arg2,
    typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>* NewPermanentClosure(
    R (*function)(BindArg1 , Arg1, Arg2, Arg3, Arg4, Arg5), BindArg1 b1) {
  return new FunctionClosure_6_1<true, R, BindArg1, Arg1, Arg2, Arg3, Arg4,
      Arg5>(
      function, b1);
}

// Specified for 6 arguments (with 2 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class FunctionClosure_6_2
  : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
  typedef R (*FunctionType)(BindArg1, BindArg2 , Arg1, Arg2, Arg3, Arg4);
 public:
  FunctionClosure_6_2(FunctionType function, BindArg1 b1, BindArg2 b2)
    : function_(function)
    , b1_(b1), b2_(b2) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_6_2> deleter(this);
    return (*function_)(b1_, b2_ , a1, a2, a3, a4);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
};

template<class R, typename BindArg1, typename BindArg2, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewClosure(
    R (*function)(BindArg1, BindArg2 , Arg1, Arg2, Arg3, Arg4), BindArg1 b1,
        BindArg2 b2) {
  return new FunctionClosure_6_2<false, R, BindArg1, BindArg2, Arg1, Arg2,
      Arg3, Arg4>(
      function, b1, b2);
}

template<class R, typename BindArg1, typename BindArg2, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2 , Arg1, Arg2, Arg3, Arg4), BindArg1 b1,
        BindArg2 b2) {
  return new FunctionClosure_6_2<true, R, BindArg1, BindArg2, Arg1, Arg2, Arg3,
      Arg4>(
      function, b1, b2);
}

// Specified for 6 arguments (with 3 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename Arg1, typename Arg2, typename Arg3>
class FunctionClosure_6_3
  : public Closure<R (Arg1, Arg2, Arg3)> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3 , Arg1, Arg2, Arg3);
 public:
  FunctionClosure_6_3(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2, Arg3 a3) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_6_3> deleter(this);
    return (*function_)(b1_, b2_, b3_ , a1, a2, a3);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3 , Arg1, Arg2, Arg3),
        BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new FunctionClosure_6_3<false, R, BindArg1, BindArg2, BindArg3, Arg1,
      Arg2, Arg3>(
      function, b1, b2, b3);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3 , Arg1, Arg2, Arg3),
        BindArg1 b1, BindArg2 b2, BindArg3 b3) {
  return new FunctionClosure_6_3<true, R, BindArg1, BindArg2, BindArg3, Arg1,
      Arg2, Arg3>(
      function, b1, b2, b3);
}

// Specified for 6 arguments (with 4 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename BindArg4, typename Arg1, typename Arg2>
class FunctionClosure_6_4
  : public Closure<R (Arg1, Arg2)> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3, BindArg4 , Arg1,
      Arg2);
 public:
  FunctionClosure_6_4(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3, BindArg4 b4)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1, Arg2 a2) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_6_4> deleter(this);
    return (*function_)(b1_, b2_, b3_, b4_ , a1, a2);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4 , Arg1, Arg2),
        BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new FunctionClosure_6_4<false, R, BindArg1, BindArg2, BindArg3,
      BindArg4, Arg1, Arg2>(
      function, b1, b2, b3, b4);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4 , Arg1, Arg2),
        BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4) {
  return new FunctionClosure_6_4<true, R, BindArg1, BindArg2, BindArg3,
      BindArg4, Arg1, Arg2>(
      function, b1, b2, b3, b4);
}

// Specified for 6 arguments (with 5 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename BindArg4, typename BindArg5, typename Arg1>
class FunctionClosure_6_5
  : public Closure<R (Arg1)> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5 ,
      Arg1);
 public:
  FunctionClosure_6_5(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3, BindArg4 b4, BindArg5 b5)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run(Arg1 a1) {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_6_5> deleter(this);
    return (*function_)(b1_, b2_, b3_, b4_, b5_ , a1);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename BindArg5, typename Arg1>
Closure<R (Arg1)>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5 , Arg1),
        BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5) {
  return new FunctionClosure_6_5<false, R, BindArg1, BindArg2, BindArg3,
      BindArg4, BindArg5, Arg1>(
      function, b1, b2, b3, b4, b5);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename BindArg5, typename Arg1>
Closure<R (Arg1)>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5 , Arg1),
        BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5) {
  return new FunctionClosure_6_5<true, R, BindArg1, BindArg2, BindArg3,
      BindArg4, BindArg5, Arg1>(
      function, b1, b2, b3, b4, b5);
}

// Specified for 6 arguments (with 6 bind-arguments)
template<bool Repeatable, class R, typename BindArg1, typename BindArg2,
    typename BindArg3, typename BindArg4, typename BindArg5, typename BindArg6>
class FunctionClosure_6_6
  : public Closure<R ()> {
  typedef R (*FunctionType)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5,
      BindArg6);
 public:
  FunctionClosure_6_6(FunctionType function, BindArg1 b1, BindArg2 b2,
      BindArg3 b3, BindArg4 b4, BindArg5 b5, BindArg6 b6)
    : function_(function)
    , b1_(b1), b2_(b2), b3_(b3), b4_(b4), b5_(b5), b6_(b6) {}
  virtual bool IsRepeatable() const { return Repeatable; }
  virtual R Run() {
    ConditionalAutoDeleter<!Repeatable, FunctionClosure_6_6> deleter(this);
    return (*function_)(b1_, b2_, b3_, b4_, b5_, b6_);
  }
 private:
  FunctionType function_;
  BindArg1 b1_;
  BindArg2 b2_;
  BindArg3 b3_;
  BindArg4 b4_;
  BindArg5 b5_;
  BindArg6 b6_;
};

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename BindArg5, typename BindArg6>
Closure<R ()>* NewClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5, BindArg6),
        BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5,
        BindArg6 b6) {
  return new FunctionClosure_6_6<false, R, BindArg1, BindArg2, BindArg3,
      BindArg4, BindArg5, BindArg6>(
      function, b1, b2, b3, b4, b5, b6);
}

template<class R, typename BindArg1, typename BindArg2, typename BindArg3,
    typename BindArg4, typename BindArg5, typename BindArg6>
Closure<R ()>* NewPermanentClosure(
    R (*function)(BindArg1, BindArg2, BindArg3, BindArg4, BindArg5, BindArg6),
        BindArg1 b1, BindArg2 b2, BindArg3 b3, BindArg4 b4, BindArg5 b5,
        BindArg6 b6) {
  return new FunctionClosure_6_6<true, R, BindArg1, BindArg2, BindArg3,
      BindArg4, BindArg5, BindArg6>(
      function, b1, b2, b3, b4, b5, b6);
}
